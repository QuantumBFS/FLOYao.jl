var documenterSearchIndex = {"docs":
[{"location":"features/features/#Features","page":"Features","title":"Features","text":"","category":"section"},{"location":"features/features/","page":"Features","title":"Features","text":"The core part of FLOYao is the a new register type, the MajoranaReg:","category":"page"},{"location":"features/features/#FLOYao.MajoranaReg","page":"Features","title":"FLOYao.MajoranaReg","text":"MajoranaReg{T} <: AbstractRegister{2}\nMajoranaReg(state::AbstractMatrix{T<:Real})\n\nA register holding the \"state\" of a Majorana operators when propagating through a FLO circuit as a 2n×2n matrix.\n\nWarning\n\nThe MajoranaReg constructor will not initialize the state matrix. It is  recommended to use FLOYao.zero_state or FLOYao.product_state to produce your initial state.\n\n\n\n\n\n","category":"type"},{"location":"features/features/#State-initialization","page":"Features","title":"State initialization","text":"","category":"section"},{"location":"features/features/","page":"Features","title":"Features","text":"There are several functions provided, to create MajoranaReg's  in different states. They are not exported from FLOYao.jl in order to avoid name collisions with Yao.jl","category":"page"},{"location":"features/features/#FLOYao.zero_state","page":"Features","title":"FLOYao.zero_state","text":"zero_state([T=Float64,] n)\n\nCreate a Majorana register on n qubits in the vacuum state Ω with storage type T.\n\n\n\n\n\n","category":"function"},{"location":"features/features/#FLOYao.zero_state_like","page":"Features","title":"FLOYao.zero_state_like","text":"zero_state_like(reg::AbstractRegister)\n\nCreate a Majorana register in the zero state with the same element type  and number of qubits as reg.\n\n\n\n\n\n","category":"function"},{"location":"features/features/#FLOYao.one_state","page":"Features","title":"FLOYao.one_state","text":"one_state([T=Float64,] n)\n\nCreate a Majorana register on n qubits in the all one state 1  1 with storage type T.\n\n\n\n\n\n","category":"function"},{"location":"features/features/#FLOYao.product_state","page":"Features","title":"FLOYao.product_state","text":"product_state([T=Float64,] bit_str::DitStr{2})\nproduct_state([T=Float64,] bit_configs::AbstractVector)\nproduct_state([T=Float64,] nbits::Int, val::Int)\n\nCreate an MajoranaReg of a product state.\n\nThe state can be specified as a bit string, as an array of Integers or Booleans or with nbits and val.\n\n\n\n\n\n","category":"function"},{"location":"features/features/#FLOYao.rand_state","page":"Features","title":"FLOYao.rand_state","text":"rand_state([Float64,] n)\n\nCreate a Haar random MajoranaReg on n qubits.\n\n\n\n\n\n","category":"function"},{"location":"features/features/","page":"Features","title":"Features","text":"as well as some functions to reset MajoranaReg's to fixed states:","category":"page"},{"location":"features/features/#FLOYao.zero_state!","page":"Features","title":"FLOYao.zero_state!","text":"zero_state!(reg::MajoranaReg)\n\nPut reg into the computational zero state\n\n\n\n\n\n","category":"function"},{"location":"features/features/#FLOYao.one_state!","page":"Features","title":"FLOYao.one_state!","text":"one_state!(reg::MajoranaReg)\n\nPut reg into the all ones state\n\n\n\n\n\n","category":"function"},{"location":"features/features/#FLOYao.product_state!","page":"Features","title":"FLOYao.product_state!","text":"product_state!(reg::MajoranaReg, bit_str::BitStr)\n\nPut reg into the product state described by bit_str\n\n\n\n\n\n","category":"function"},{"location":"features/features/#Applying-gates","page":"Features","title":"Applying gates","text":"","category":"section"},{"location":"features/features/","page":"Features","title":"Features","text":"Application of Supported gates to MajoranaReg's works  as it does in Yao.jl","category":"page"},{"location":"features/features/","page":"Features","title":"Features","text":"reg = FLOYao.zero_state(2)\ngate = put(2, 1 => X)\n\n# using apply!\napply!(reg, gate)\n\n# or using the pipe syntax\nreg |> gate\n\n# or the non-mutating version\nresult = apply(reg, gate)","category":"page"},{"location":"features/features/#Measuring-expectation-values","page":"Features","title":"Measuring expectation values","text":"","category":"section"},{"location":"features/features/","page":"Features","title":"Features","text":"Measuring expectation values with respect to (almost) arbitrary Yao.AbstractBlocks works exactly the same way it does in Yao.jl using expect:","category":"page"},{"location":"features/features/#YaoAPI.expect","page":"Features","title":"YaoAPI.expect","text":"expect(op::Union{AbstractBlock,MajoranaSum}, reg::MajoranaReg)\nexpect(op::Union{AbstractBlock,MajoranaSum}, (reg => circuit)::Pair{<:MajoranaReg,<:AbstractBlock})\n\nGet the expectation value of an operator, the second parameter can be a register reg or a pair of input register and circuit reg => circuit.\n\nexpect'(op::Union{AbstractBlock,MajoranaSum}, reg => circuit::) -> Pair{<:MajoranaReg,<:AbstractVector}\nexpect'(op::Union{AbstractBlock,MajoranaSum}, reg::MajoranaReg) -> MajoranaReg\n\nObtain the gradient with respect to registers and circuit parameters. For pair input, the second return value is a pair of gψ => gparams, with gψ the gradient of input state and gparams the gradients of circuit parameters. For register input, the return value is a register.\n\n\n\n\n\n","category":"function"},{"location":"features/features/","page":"Features","title":"Features","text":"But if you need convert expectation values many times with respect to the same observable op it is recommended to convert the Yao.AbstractBlock to a  MajoranaSum which acts as a (more performant) replacement of op in expect and expect':","category":"page"},{"location":"features/features/#FLOYao.MajoranaSum","page":"Features","title":"FLOYao.MajoranaSum","text":"MajoranaSum{T}\nMajoranaSum(terms::Vector{MajoranaTerm{T}})\nMajoranaSum(terms::Dict{Vector{Int}, T})\nMajoranaSum(op::AbstractBlock)\n\nA sum of FLOYao.MajoranaTerms to be used as a more performant replacement of op::Yao.AbstractBlock in expect and expect'\n\nYao.AbstractBlocks that are sums of (scaled) tensor products of Pauli gates can be directly converted to MajoranaSums:\n\njulia> yaoham = (put(4, 1=>Z) + 2kron(4, 1=>X, 2=>Z, 3=>Z, 4=>X) + 3.5put(4, 2=>Z)\n                 + 0.5kron(4, 1=>Z, 2=>Z) - kron(4, 2 => X, 4 => Y));\n\njulia> MajoranaSum(yaoham)\n5-element MajoranaSum{ComplexF64}:\n  [4, 5, 6, 8] : -1.0 - 0.0im\n  [2, 7] : 0.0 + 2.0im\n  [1, 2, 3, 4] : -0.5 - 0.0im\n  [1, 2] : 0.0 - 1.0im\n  [3, 4] : 0.0 - 3.5im\n\n\n\n\n\n","category":"type"},{"location":"features/features/#FLOYao.MajoranaTerm","page":"Features","title":"FLOYao.MajoranaTerm","text":"MajoranaTerm{T}\nMajoranaTerm(coeff::Number, indices::Vector{Int})\n\nA Majorana monomial represented by its coefficient and indices on which it acts non-trivially.\n\n\n\n\n\n","category":"type"},{"location":"features/features/#Sampling","page":"Features","title":"Sampling","text":"","category":"section"},{"location":"features/features/","page":"Features","title":"Features","text":"Samples in the computational basis can be obtained with the same functions as  in Yao.jl:","category":"page"},{"location":"features/features/#YaoAPI.measure-Tuple{MajoranaReg}","page":"Features","title":"YaoAPI.measure","text":"measure(reg::MajoranaReg[, locs]; nshots=1, rng=Random.GLOBAL_RNG) -> Vector{BitStr}\n\nMeasure a MajoranaReg and return the results as a vector of BitStrings. This is a cheating version of measure! that does not need to recompute the reg  for each new sample and also does not alter it.\n\nArguments\n\nreg::MajoranaReg: The state register\nlocs: The list of qubits to measure. Defaults to all qubits.\nnshots=1: The number of samples to take\nrng=Random.GLOBAL_RNG: The random number generator to use\n\n\n\n\n\n","category":"method"},{"location":"features/features/#YaoAPI.measure!-Tuple{MajoranaReg}","page":"Features","title":"YaoAPI.measure!","text":"measure!([postprocess::Union{NoPostProcess, ResetTo},] reg::MajoranaReg; rng=Random.GLOBAL_RNG)\n\nMeasure a Majorana register in the computational basis and return the  resulting BitStr.\n\nArguments\n\npostprocess: Is the post processing method\nNoPostProcess() (the default) will collapse the state to the measurement                   outcome state.\nResetTo(bit_str) will reset the state to the product state specified by                     bit_str\nreg::MajoranaReg: The quantum register\nrng::Random.GLOBAL_RNG: The RNG to use\n\n\n\n\n\n","category":"method"},{"location":"features/features/#Fidelities-and-bitstring-probabilities","page":"Features","title":"Fidelities and bitstring probabilities","text":"","category":"section"},{"location":"features/features/","page":"Features","title":"Features","text":"Fidelities between two MajoranaRegs can be computed the same way as in  Yao.jl:","category":"page"},{"location":"features/features/#YaoAPI.fidelity-Tuple{MajoranaReg, MajoranaReg}","page":"Features","title":"YaoAPI.fidelity","text":"fidelity(reg1::MajoranaReg, reg2::MajoranaReg)\nfidelity'(pair_or_majoranareg, pair_or_majoranareg) -> (g1, g2)\n\nThe fidelity ψφ between the FLO states ψ and φ defined by reg1 and reg2.\n\nThe gradient with respect to registers and circuit parameters. For a pair input reg => circuit the returned gradient is a pair of greg => gparams with greg the gradient with respect to the input state and gparams the gradient with respect to circuit parameters. For a reg input the return value is the gradient with respect to the register.\n\nnote: Note\nThis definition differs from the standard definition φψ² by a square  root, but is consistent with the one used in Yao.jl\n\n\n\n\n\n","category":"method"},{"location":"features/features/","page":"Features","title":"Features","text":"Under the hood this function uses a non-exported function to compute the  probability of obtaining a given bit_string as an output when measuring in  the computational basis:","category":"page"},{"location":"features/features/#FLOYao.bitstring_probability","page":"Features","title":"FLOYao.bitstring_probability","text":"bitstring_probability(reg::MajoranaReg, bit_string::BitStr)\n\nThe probability to measure a given bit_string when measuring reg\n\nTodo\n\nRewrite this using pfaffians\n\n\n\n\n\n","category":"function"},{"location":"features/features/#Non-exported-functions","page":"Features","title":"Non-exported functions","text":"","category":"section"},{"location":"features/features/","page":"Features","title":"Features","text":"The following functions are not exported and not really needed for the  functionality of FLOYao, but can be useful for debugging.","category":"page"},{"location":"features/features/#FLOYao.paulibasis2qubitop","page":"Features","title":"FLOYao.paulibasis2qubitop","text":"paulibasis2qubitop(P::AbstractVector)\n\nConverts an operator to in the pauli basis to a matrix in the computational basis. Inverse to qubit2paulibasis.\n\n\n\n\n\n","category":"function"},{"location":"features/features/#FLOYao.majoranasquares2qubitbasis","page":"Features","title":"FLOYao.majoranasquares2qubitbasis","text":"majoranasquares2qubitbasis(H::AbstractMatrix)\n\nConverts an 2n2n Majorana hamiltonian H into the full 2^n2^n hamiltonian in the qubit basis.\n\n\n\n\n\n","category":"function"},{"location":"features/features/#FLOYao.qubit2paulibasis","page":"Features","title":"FLOYao.qubit2paulibasis","text":"qubit2paulibasis(A::AbstractMatrix)\n\nConverts a 2^n2^n matrix A in the standard qubit basis into a  4^n vector representing the same operator in the Pauli basis.\n\nThe ordering is as follows: Let σ^0 = I σ^1 = X σ^2 = Y and σ^3 = Z. \n\nTodo\n\nCreating the dense pauli tensor product via kron and inner product via dot is much slower than neccessary, since the pauli tensor product matrix is  very sparse. Much faster would be to compute the inner product directly.\n\n\n\n\n\n","category":"function"},{"location":"features/features/#FLOYao.qubit2majoranaevolution","page":"Features","title":"FLOYao.qubit2majoranaevolution","text":"qubit2majoranaevolution(U::AbstractMatrix, locs)\n\nTurns a n qubit unitary U on the n qubits in locs into the corresponding SO(2n2n) matrix for the evolution of the Majorana operators.\n\n\n\n\n\n","category":"function"},{"location":"features/features/#FLOYao.paulibasis2majoranasquares","page":"Features","title":"FLOYao.paulibasis2majoranasquares","text":"paulibasis2majoranasquares(P::AbstractVector, locs=1:log4(length(P)))\n\nConvert an operator written in the Pauli basis as a 4^n-element vector to the corresponding 2n2n matrix of coefficients of products of two Majorana operators.\n\nThrows a NonFLOException if P contains terms that are not corresponding to the product of two Majorana operators.\n\n\n\n\n\n","category":"function"},{"location":"features/features/#FLOYao.yaoham2majoranasquares","page":"Features","title":"FLOYao.yaoham2majoranasquares","text":"yaoham2majoranasquares(::Type{T}=Float64, yaoham::AbstracBlock{2})\n\nConvert a hamiltonian written as a YaoBlock into the corresponding  2n2n majorana hamiltonian.\n\n\n\n\n\n","category":"function"},{"location":"features/features/#FLOYao.yaoblock2majoranasum","page":"Features","title":"FLOYao.yaoblock2majoranasum","text":"yaoham2majoranasum(::Type{T}=Float64, yaoham::AbstracBlock{2})\n\nConvert a  YaoBlock into a MajoranaSum{complex(T)}\n\n\n\n\n\n","category":"function"},{"location":"features/features/#FLOYao.majorana2arrayreg","page":"Features","title":"FLOYao.majorana2arrayreg","text":"majorana2arrayreg(reg::MajoranaReg)\n\nConverts a 2n×2n MajoranaReg reg into a 2^n ArrayReg.\n\nNote\n\nThis implementation is not very clever and should mainly be used for debugging purposes with small numbers of qubits. It pipes a random state ψ  through the projector UΩΩU^ which may give inaccurate results if  ψUψ is very small.\n\n\n\n\n\n","category":"function"},{"location":"features/features/#FLOYao.random_orthogonal_matrix","page":"Features","title":"FLOYao.random_orthogonal_matrix","text":"random_orthogonal_matrix([::Type{T}=Float64,] n)\n\nGenerate a Haar random matrix in O(n) with element type T  using the algorithm described in How to generate random matrices from the classical compact groups\n\n\n\n\n\n","category":"function"},{"location":"vqe_example/#Example:-VQE-for-the-transverse-field-Ising-model","page":"Example: VQE for the TFIM","title":"Example: VQE for the transverse field Ising model","text":"","category":"section"},{"location":"vqe_example/","page":"Example: VQE for the TFIM","title":"Example: VQE for the TFIM","text":"One prime example of a free fermion Hamiltonian and FLO circuit is  the variational quantum eigensolver with the hamiltonian variational ansatz  applied  the transverse field Ising model. It is a good example demonstrating the capabilities of FLOYao.","category":"page"},{"location":"vqe_example/","page":"Example: VQE for the TFIM","title":"Example: VQE for the TFIM","text":"The Hamiltonian is given as ","category":"page"},{"location":"vqe_example/","page":"Example: VQE for the TFIM","title":"Example: VQE for the TFIM","text":"    H = J _i^L-1 X_i X_i+1 + h _i^L Z_i = U + T","category":"page"},{"location":"vqe_example/","page":"Example: VQE for the TFIM","title":"Example: VQE for the TFIM","text":"and as Ansatz circuits we use the Hamiltonian Variational Ansatz","category":"page"},{"location":"vqe_example/","page":"Example: VQE for the TFIM","title":"Example: VQE for the TFIM","text":"    U(vec θ) = _i^p e^-iθ_iU U e^-iθ_iT T ","category":"page"},{"location":"vqe_example/","page":"Example: VQE for the TFIM","title":"Example: VQE for the TFIM","text":"with the initial state being the groundstate of the TFIM at J = 0, so ψ_i = 0  0.","category":"page"},{"location":"vqe_example/","page":"Example: VQE for the TFIM","title":"Example: VQE for the TFIM","text":"First, we define the Hamiltonian","category":"page"},{"location":"vqe_example/","page":"Example: VQE for the TFIM","title":"Example: VQE for the TFIM","text":"using FLOYao, Yao\nL = 100 # this is far beyond what is possible with a full wavefunction simulation\nJ = 1.5 \nh = -1.\np = 10  # number of VQE layers\nU = map(1:L-1) do i\n    J * kron(L, i => X, i+1 => X)\nend |> sum\n\nT = map(1:L) do i\n    h * kron(L, i => Z)\nend |> sum\n\nhamiltonian = T + U\n\n# only here due to Documenter.jl restrictions\nsummary(hamiltonian)\n\n# output\n\"Add{2}\"","category":"page"},{"location":"vqe_example/","page":"Example: VQE for the TFIM","title":"Example: VQE for the TFIM","text":"and convert it to a MajoranaSum","category":"page"},{"location":"vqe_example/","page":"Example: VQE for the TFIM","title":"Example: VQE for the TFIM","text":"majorana_hamiltonian = MajoranaSum(hamiltonian)\n\n# only here due to Documenter.jl restrictions\nsummary(majorana_hamiltonian)\n\n# output\n\"MajoranaSum{ComplexF64}\"","category":"page"},{"location":"vqe_example/","page":"Example: VQE for the TFIM","title":"Example: VQE for the TFIM","text":"tip: Faster expectation values with `MajoranaSum`\nStrictly speaking, it is not neccessary to convert the hamiltonian from Yao.AbstractBlock to MajoranaSum; expect(::AbstractBlock, ::MajoranaReg) is also implemented. But if you need to take expectation values with respect the same Hamiltonian many times–-as is the case for variational algorithms–- doing this conversion improves the performance of expect and expect'.","category":"page"},{"location":"vqe_example/","page":"Example: VQE for the TFIM","title":"Example: VQE for the TFIM","text":"Then we can also define the ansatz circuit","category":"page"},{"location":"vqe_example/","page":"Example: VQE for the TFIM","title":"Example: VQE for the TFIM","text":"circuit = chain(L)\nfor _ in 1:p\n    for i in 1:L-1\n        push!(circuit, rot(kron(L, i => X, i+1 => X), 0.))\n    end\n    for i in 1:L\n        push!(circuit, put(L, i => Rz(0.)))\n    end\nend\n\n# output","category":"page"},{"location":"vqe_example/","page":"Example: VQE for the TFIM","title":"Example: VQE for the TFIM","text":"as well as the initial state","category":"page"},{"location":"vqe_example/","page":"Example: VQE for the TFIM","title":"Example: VQE for the TFIM","text":"reg = FLOYao.zero_state(L)\ntypeof(reg)\n\n# output\nMajoranaReg{Float64}","category":"page"},{"location":"vqe_example/","page":"Example: VQE for the TFIM","title":"Example: VQE for the TFIM","text":"Now that we defined the hamiltonian, the ansatz circuit and the initial state we can perform simple gradient descent on the energy expectation value to find an approximation to the groundstate of H:","category":"page"},{"location":"vqe_example/","page":"Example: VQE for the TFIM","title":"Example: VQE for the TFIM","text":"iterations = 100\ngamma = 2e-2\n\n# set the initial parameters\nnparams = nparameters(circuit)\ndispatch!(circuit, ones(nparams) ./ 100) # fix initial parameters for reproducibility\n\nfor i in 1:iterations\n    _, grad = expect'(majorana_hamiltonian, reg => circuit)\n    dispatch!(-, circuit, gamma * grad)\n    println(\"Iteration $i, energy = $(round(expect(hamiltonian, reg => circuit), digits=4))\")\nend\n\n# output\nIteration 1, energy = -99.7577\nIteration 2, energy = -100.1858\nIteration 3, energy = -100.3843\nIteration 4, energy = -100.6364\nIteration 5, energy = -101.0342\nIteration 6, energy = -101.6735\nIteration 7, energy = -102.6934\nIteration 8, energy = -104.2918\nIteration 9, energy = -106.7225\nIteration 10, energy = -110.2443\nIteration 11, energy = -114.983\nIteration 12, energy = -120.7112\nIteration 13, energy = -126.7071\nIteration 14, energy = -131.975\nIteration 15, energy = -135.8116\nIteration 16, energy = -138.1614\nIteration 17, energy = -139.4181\nIteration 18, energy = -140.0345\nIteration 19, energy = -140.3264\nIteration 20, energy = -140.4677\nIteration 21, energy = -140.5422\nIteration 22, energy = -140.5877\nIteration 23, energy = -140.6206\nIteration 24, energy = -140.648\nIteration 25, energy = -140.6729\nIteration 26, energy = -140.6966\nIteration 27, energy = -140.7196\nIteration 28, energy = -140.7423\nIteration 29, energy = -140.7647\nIteration 30, energy = -140.7869\nIteration 31, energy = -140.809\nIteration 32, energy = -140.831\nIteration 33, energy = -140.8529\nIteration 34, energy = -140.8747\nIteration 35, energy = -140.8965\nIteration 36, energy = -140.9182\nIteration 37, energy = -140.9398\nIteration 38, energy = -140.9614\nIteration 39, energy = -140.983\nIteration 40, energy = -141.0045\nIteration 41, energy = -141.026\nIteration 42, energy = -141.0475\nIteration 43, energy = -141.0689\nIteration 44, energy = -141.0904\nIteration 45, energy = -141.1118\nIteration 46, energy = -141.1332\nIteration 47, energy = -141.1545\nIteration 48, energy = -141.1759\nIteration 49, energy = -141.1973\nIteration 50, energy = -141.2187\nIteration 51, energy = -141.24\nIteration 52, energy = -141.2614\nIteration 53, energy = -141.2828\nIteration 54, energy = -141.3042\nIteration 55, energy = -141.3256\nIteration 56, energy = -141.347\nIteration 57, energy = -141.3685\nIteration 58, energy = -141.3899\nIteration 59, energy = -141.4114\nIteration 60, energy = -141.4329\nIteration 61, energy = -141.4544\nIteration 62, energy = -141.476\nIteration 63, energy = -141.4976\nIteration 64, energy = -141.5193\nIteration 65, energy = -141.5409\nIteration 66, energy = -141.5627\nIteration 67, energy = -141.5844\nIteration 68, energy = -141.6062\nIteration 69, energy = -141.6281\nIteration 70, energy = -141.65\nIteration 71, energy = -141.672\nIteration 72, energy = -141.694\nIteration 73, energy = -141.7161\nIteration 74, energy = -141.7383\nIteration 75, energy = -141.7605\nIteration 76, energy = -141.7829\nIteration 77, energy = -141.8052\nIteration 78, energy = -141.8277\nIteration 79, energy = -141.8503\nIteration 80, energy = -141.8729\nIteration 81, energy = -141.8956\nIteration 82, energy = -141.9184\nIteration 83, energy = -141.9414\nIteration 84, energy = -141.9644\nIteration 85, energy = -141.9875\nIteration 86, energy = -142.0107\nIteration 87, energy = -142.0341\nIteration 88, energy = -142.0576\nIteration 89, energy = -142.0812\nIteration 90, energy = -142.1049\nIteration 91, energy = -142.1287\nIteration 92, energy = -142.1527\nIteration 93, energy = -142.1768\nIteration 94, energy = -142.2011\nIteration 95, energy = -142.2255\nIteration 96, energy = -142.25\nIteration 97, energy = -142.2748\nIteration 98, energy = -142.2997\nIteration 99, energy = -142.3247\nIteration 100, energy = -142.3499","category":"page"},{"location":"vqe_example/","page":"Example: VQE for the TFIM","title":"Example: VQE for the TFIM","text":"Hopefully, this is a good enough approximation to the groundstate. We can now  use this to sample from the state we found:","category":"page"},{"location":"vqe_example/","page":"Example: VQE for the TFIM","title":"Example: VQE for the TFIM","text":"using Random\nsamples = measure(reg |> circuit, nshots=10, rng=MersenneTwister(42))\n\n# output\n\n10-element Vector{BitStr{100, BigInt}}:\n 0000000000000000000000000001111000000000000000000000000000000000000000000000000000000000000000000000 ₍₂₎\n 0000000000000000000110011000000000000000101000000110000000000000000000000000000000000000000000000000 ₍₂₎\n 0000000000011000110000000000000000000000000000000000000000001101100000000011001100000001100000000000 ₍₂₎\n 1100000000000000000000001111000110000000000000000000000000000000000000000011000110000001010011000000 ₍₂₎\n 0000000000000000000000000000000000000000000000000000000000001010000110000000000000000000000000000000 ₍₂₎\n 0000000000000000000000000000110000000000100100000011000000011000000000000000000000000000110000000000 ₍₂₎\n 1100000001100000001100110000000000000000000110000000000000110000100100000000000000110000000000000011 ₍₂₎\n 0000000000000000101000000000000000000010100000000000000000000000001100000000000110000000000000000000 ₍₂₎\n 0000000000000000000000000001100000000001101100000000000000000000000000000000000000000011000000000000 ₍₂₎\n 0101000000000000000000000000000011000000000000000000000000000000000000000000000000000000000000000000 ₍₂₎","category":"page"},{"location":"features/supported_gates/#Supported-gates","page":"Supported Gates","title":"Supported gates","text":"","category":"section"},{"location":"features/supported_gates/","page":"Supported Gates","title":"Supported Gates","text":"The following gates are FLO gates and supported by FLOYao.jl:","category":"page"},{"location":"features/supported_gates/","page":"Supported Gates","title":"Supported Gates","text":"Gate Comment\nXGate Together with Y the only gate that does not preserve fermionic parity\nYGate See above\nZGate \nRotationGate{⋯,⋯,ZGate} The only single qubit rotation gate since R_x(θ)γ_i R_x(-θ) is not a linear combination of Majorana operators for all Majorana operators. Similar for R_y\nPauliKronBlock A kronecker product of Pauli operators s.t. that first and last operator are either X or Y and all operators in between are Z.\nRotationGate{⋯,⋯,PauliKronBlock} A rotation gate with generator as in the last line.\nKronBlock{⋯,⋯,RotationGate{⋯}} Kronecker products of supported Rotation gates (i.e. those that are generated by supported PauliKronBlocks)\nTimeEvolution Time evolution with FLO hamiltonians, i.e. sums of PauliKronBlocks\nAbstractMatrix Unless the gate type is already explicitely implemented or know to not be a FLO gate, FLOYao will try to automatically convert the gate matrix in the qubit basis to a matrix in the Majorana basis. But note that this is fairly slow (although still poly-time instead of exp-time)","category":"page"},{"location":"features/supported_gates/","page":"Supported Gates","title":"Supported Gates","text":"If you want to add support to your own gates, read Adding support for custom gates to learn how to do that.","category":"page"},{"location":"known_restrictions/#Known-restrictions","page":"Known restrictions","title":"Known restrictions","text":"","category":"section"},{"location":"known_restrictions/#\"Hidden\"-FLO-circuits","page":"Known restrictions","title":"\"Hidden\" FLO circuits","text":"","category":"section"},{"location":"known_restrictions/","page":"Known restrictions","title":"Known restrictions","text":"Yao.jl allows to express the same circuit in different forms. E.g. ","category":"page"},{"location":"known_restrictions/","page":"Known restrictions","title":"Known restrictions","text":"chain(nq, put(1 => X), put(2 => X))","category":"page"},{"location":"known_restrictions/","page":"Known restrictions","title":"Known restrictions","text":"and","category":"page"},{"location":"known_restrictions/","page":"Known restrictions","title":"Known restrictions","text":"kron(nq, 1 => X, 2 => X)","category":"page"},{"location":"known_restrictions/","page":"Known restrictions","title":"Known restrictions","text":"represent the same FLO circuit, but only the latter will be recognised as such. Similarly ","category":"page"},{"location":"known_restrictions/","page":"Known restrictions","title":"Known restrictions","text":"kron(nq, 1 => X, 2 => X, 3 => X, 4 => X)","category":"page"},{"location":"known_restrictions/","page":"Known restrictions","title":"Known restrictions","text":"and","category":"page"},{"location":"known_restrictions/","page":"Known restrictions","title":"Known restrictions","text":"chain(nq, kron(1 => X, 2 => X), kron(3 => X, 4 => X))","category":"page"},{"location":"known_restrictions/","page":"Known restrictions","title":"Known restrictions","text":"represent the same FLO circuit but only the latter will be recognised as such. This is because","category":"page"},{"location":"known_restrictions/","page":"Known restrictions","title":"Known restrictions","text":"We don't check if a whole ChainBlock is a FLO circuit, even if its single gates are not. Instead a ChainBlock is applied gate by gate, each of which has to be a FLO gate.\nFor KronBlocks we first try if each factor is a FLO gate and then if the whole block altogether is of the form  kron(nq, i => σ1, i+1 => Z, ⋯, i-1 => Z, j => σ2) with σ1, σ2 ∈ [X, Y].","category":"page"},{"location":"known_restrictions/","page":"Known restrictions","title":"Known restrictions","text":"If you run into a case that is a FLO circuit / gate but not recognised as such please open an issue or even pull request.","category":"page"},{"location":"background/#background","page":"Mathematical Background","title":"Mathematical Background","text":"","category":"section"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"This section is here, more to fix the convention of Jordan-Wigner transform and Majorana operators that we use here, and less to explain the full theory behind those. For the latter, we, once again, recommend Classical simulation of noninteracting-fermion quantum circuits.","category":"page"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"We define the Majorana operators γ_i via ","category":"page"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"    γ_2i-1 = _j=1^i-1 (-Z_j) X_i\n    qquad textrmand qquad\n    γ_2i = -_j=1^i-1 (-Z_j) Y_i","category":"page"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"This implies the normal fermionic creation and annihilation operators are given by","category":"page"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"    c_j = frac12 (γ_2j-1 + iγ_2j)\n    quad textrmand quad\n    c_j^ = frac12 (γ_2j-1 - iγ_2j)","category":"page"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"and products of two Majorana operators are of the form","category":"page"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"    σ_i left(_ijk -Z_j right) σ_k\n    quad textrmor quad\n    Z_i","category":"page"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"with σ_i σ_k  X Y.","category":"page"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"Any unitary that takes all Majorana operators to a linear combination of Majorana operators under conjugation, i.e. that satisfies","category":"page"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"    U γ_i U^ = R_i^j γ_j","category":"page"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"with some R  O(2n) is a FLO unitary. In particular, if a unitary is of the form ","category":"page"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"    U = e^-iθH","category":"page"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"with ","category":"page"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"    H = fraci4 sum_ij H^ij γ_i γ_j","category":"page"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"it is a FLO unitary with R  SO(2n).","category":"page"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"But note, that not all FLO unitaries are of that form. For example, X_i is also a FLO gate since it either commutes or anti-commutes with all Majorana operators, but the associated matrix R always has determinant -1.","category":"page"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"Calculating the expectation values of hamiltonians like the one above when evolving the vacuum state with FLO circuits is efficiently possible. First evolve the Hamiltonian in the Heisenber picture to","category":"page"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"    UHU^ = fraci4 R^m_i R^n_j H^ij γ_m γ_n \n           = fraci4 tilde H^mn γ_m γ_n","category":"page"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"and then compute the expectation value","category":"page"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"beginaligned\n    ψUHU^ψ = fraci4 tilde H^mn Ωγ_m γ_nΩ \n                = - frac12 _i tilde H^2i-12i \n                = - frac12 _i R^2i-1_m R^2i_n H^mn \nendaligned","category":"page"},{"location":"background/","page":"Mathematical Background","title":"Mathematical Background","text":"From the first to second line one needs to carefully think which of the  Ωγ_m γ_nΩ are zero and which cancel each other out due to the anti-symmetry of H^mn.","category":"page"},{"location":"#FLOYao","page":"Home","title":"FLOYao","text":"","category":"section"},{"location":"#FLOYao.FLOYao","page":"Home","title":"FLOYao.FLOYao","text":"A Yao.jl backend to efficiently simulate fermionic linear optics (FLO) circuits  based on Classical simulation of noninteracting-fermion quantum circuits and Disorder-assisted error correction in Majorana chains. FLO circuits are a class of quantum circuits that are closely related to non-interacting fermions and can be efficiently simulated on classical computers, similar to the way Clifford circuits can be efficiently classically simulated, as is done in YaoClifford.jl.\n\nThe goal of FLOYao.jl is that if you have code written in Yao.jl that only  uses FLO gates and other primitives that are efficiently simulatable in polynomial time and  space, that you can simply replace your AbstractArrayReg with a MajoranaReg and run exactly the same simulation, with the same code but exponentially faster.\n\nA brief introduction to fermionic linear optics circuits is found in the  Documentation and a more in-depth introduction in e.g. the two papers linked above.\n\n\n\n\n\n","category":"module"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"FLOYao can be simply installed from the REPL via","category":"page"},{"location":"","page":"Home","title":"Home","text":"pkg> add FLOYao","category":"page"},{"location":"#Quickstart","page":"Home","title":"Quickstart","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"First import FLOYao and Yao","category":"page"},{"location":"","page":"Home","title":"Home","text":"using FLOYao, Yao\n\n# output","category":"page"},{"location":"","page":"Home","title":"Home","text":"then build a (here somewhat arbitrary) circuit consisting only of Supported gates","category":"page"},{"location":"","page":"Home","title":"Home","text":"nq = 4\nθ = π/8\ncircuit = chain(nq)\n\npush!(circuit, put(nq, 3=>Rz(0.5)))\n\nxxg1 = kron(nq, 1 => X, 2 => X)\nrg = rot(xxg1, θ)\npush!(circuit, rg)  \n\nxxg2 = kron(nq, 2 => X, 3 => Z, 4 => X)\nrg = rot(xxg2, θ)\npush!(circuit, rg)  \npush!(circuit, put(nq, 3=>Rz(0.5)))\npush!(circuit, put(nq, 1=>Z))\n\nxxg3 = kron(nq, 2 => X, 3 => X)\nrg = rot(xxg3, θ)\n\ncircuit","category":"page"},{"location":"","page":"Home","title":"Home","text":"and define a (here similarly arbitrary) observable","category":"page"},{"location":"","page":"Home","title":"Home","text":"hamiltonian = (kron(nq, 1=>Z) + 2kron(nq, 1=>X, 2=>Z, 3=>Z, 4=>X) + 3.5put(nq, 2=>Z)\n               + 0.5kron(nq, 1=>Z, 2=>Z) - kron(nq, 2 => X, 4 => Y))","category":"page"},{"location":"","page":"Home","title":"Home","text":"and finally create a register in the computational zero state via","category":"page"},{"location":"","page":"Home","title":"Home","text":"reg = FLOYao.zero_state(nq)\n\n# output\nMajoranaReg{Float64} with 4 qubits:\n 1.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  1.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  1.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  1.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  1.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  1.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  1.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  1.0","category":"page"},{"location":"","page":"Home","title":"Home","text":"Applying the circuit to the register works then exactly the same way as for a normal ArrayReg register:","category":"page"},{"location":"","page":"Home","title":"Home","text":"apply(reg, circuit)\n\n# output\nMajoranaReg{Float64} with 4 qubits:\n -1.0  -0.0                 -0.0                 …  -0.0                 -0.0\n -0.0  -0.9238795325112867   0.3826834323650898     -0.0                 -0.0\n  0.0   0.3826834323650898   0.9238795325112867      0.0                  0.0\n  0.0   0.0                  0.0                     0.3826834323650898   0.0\n  0.0   0.0                  0.0                     0.0                  0.0\n  0.0   0.0                  0.0                 …   0.0                  0.0\n  0.0   0.0                  0.0                     0.9238795325112867   0.0\n  0.0   0.0                  0.0                     0.0                  1.0","category":"page"},{"location":"","page":"Home","title":"Home","text":"and the same goes for expectation values of observables","category":"page"},{"location":"","page":"Home","title":"Home","text":"expect(hamiltonian, reg => circuit)\n\n# output\n5.04883281702193","category":"page"},{"location":"","page":"Home","title":"Home","text":"or even gradients of these expectation values with respect to the circuit parameters","category":"page"},{"location":"","page":"Home","title":"Home","text":"state_grad, params_grad = expect'(hamiltonian, reg => circuit)\n\n# output\nMajoranaReg{Float64}(4) => [0.0, -0.9130135182550002, 0.20220773043883133, -5.551115123125783e-17]","category":"page"},{"location":"#Contents","page":"Home","title":"Contents","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n    \"vqe_example.md\",\n    \"features/features.md\",\n    \"features/supported_gates.md\",\n    \"background.md\",\n    \"adding_gates.md\",\n    \"known_restrictions.md\"\n]","category":"page"},{"location":"adding_gates/#Adding-support-for-custom-gates","page":"Adding custom gates","title":"Adding support for custom gates","text":"","category":"section"},{"location":"adding_gates/","page":"Adding custom gates","title":"Adding custom gates","text":"Natively, the only FLO gates that come already shipped with FLOYao.jl are these Supported gates. But there are many more FLO gates, one being for example the FSWAP gate which swaps to qubits while making sure to preserve the fermionic commutation relations","category":"page"},{"location":"adding_gates/","page":"Adding custom gates","title":"Adding custom gates","text":"@const_gate FSWAP::ComplexF64 = [1 0 0 0; 0 0 1 0; 0 1 0 0; 0 0 0 -1]","category":"page"},{"location":"adding_gates/","page":"Adding custom gates","title":"Adding custom gates","text":"If a gate defines a matrix representation, as we just did for the FSWAPgate, FLOYao supports them out of the box by manually checking if they are a FLO gate and then computing its matrix representation in the Majorana basis. But this method is fairly slow–-though still poly-time and memory–-compared to directly implementing unsafe_apply!(::MajoranaReg, ::YourBlock) and instruct!(::MajoranaReg, ::YourBlock) and will warn you accordingly:","category":"page"},{"location":"adding_gates/","page":"Adding custom gates","title":"Adding custom gates","text":"nq = 4\nfswap = put(nq, (1, 2) => FSWAP)\nmreg = FLOYao.zero_state(nq)\nmreg |> put(nq, 2 => X)\nmreg |> fswap","category":"page"},{"location":"adding_gates/","page":"Adding custom gates","title":"Adding custom gates","text":"┌ Warning: Calling manual instruct!(MajoranaReg{Float64}(4), ComplexF64[1.0 + 0.0im 0.0 + 0.0im 0.0 + 0.0im 0.0 + 0.0im; 0.0 + 0.0im 0.0 + 0.0im 1.0 + 0.0im 0.0 + 0.0im; 0.0 + 0.0im 1.0 + 0.0im 0.0 + 0.0im 0.0 + 0.0im; 0.0 + 0.0im 0.0 + 0.0im 0.0 + 0.0im -1.0 + 0.0im], (1, 2)).\n│ You can greatly speed up your FLO gates by exactly implementing unsafe_apply!()\n│ and instruct!() for them. See FLOYao/src/instruct.jl and  FLOYao/src/apply_composite.jl\n│ for how to do that.\n└ @ FLOYao ~/.julia/.../FLOYao/src/instruct.jl:56\n\nMajoranaReg{Float64} with 4 qubits:\n -2.35415e-16  -4.12493e-16  -1.0          …   0.0   0.0   0.0   0.0\n  2.46746e-16  -5.5708e-16   -1.26504e-16      0.0   0.0   0.0   0.0\n -1.0          -1.17708e-16   2.55988e-16      0.0   0.0   0.0   0.0\n -1.85286e-16  -1.0           2.44068e-16      0.0   0.0   0.0   0.0\n -0.0          -0.0          -0.0             -1.0  -0.0  -0.0  -0.0\n -0.0          -0.0          -0.0          …  -0.0  -1.0  -0.0  -0.0\n -0.0          -0.0          -0.0             -0.0  -0.0  -1.0  -0.0\n -0.0          -0.0          -0.0             -0.0  -0.0  -0.0  -1.0","category":"page"},{"location":"adding_gates/","page":"Adding custom gates","title":"Adding custom gates","text":"Now, before we fix these warnings, let's see how long the current implementation takes:","category":"page"},{"location":"adding_gates/","page":"Adding custom gates","title":"Adding custom gates","text":"using BenchmarkTools\nusing Suppressor # we don't want to get all the warnings when benchmarking\n@benchmark @suppress apply!($mreg, $fswap)","category":"page"},{"location":"adding_gates/","page":"Adding custom gates","title":"Adding custom gates","text":"BenchmarkTools.Trial: 6524 samples with 1 evaluation.\n Range (min … max):  707.996 μs …   3.773 ms  ┊ GC (min … max): 0.00% … 73.67%\n Time  (median):     727.015 μs               ┊ GC (median):    0.00%\n Time  (mean ± σ):   761.750 μs ± 225.610 μs  ┊ GC (mean ± σ):  2.31% ±  6.25%\n\n  ▆█▇▆▅▄▄▄▃▃▂▂▁▁                                                ▂\n  ███████████████▇██▇▇▃▅▅▄▅▅▄▃▄▁▃▃▁▁▃▃▃▃▁▃▁▃▁▁▁▃▁▄▁▁▁▃▃▆▆▆▆▆▆▄▄ █\n  708 μs        Histogram: log(frequency) by time        1.2 ms <\n\n Memory estimate: 338.53 KiB, allocs estimate: 495.","category":"page"},{"location":"adding_gates/","page":"Adding custom gates","title":"Adding custom gates","text":"To find out what the matrix representation of the FSWAP gate in the Majorana basis is, it is easiest to retrace what is happening inside instruct!(::MajoranaReg, ::AbstractMatrix, locs). You can use","category":"page"},{"location":"adding_gates/","page":"Adding custom gates","title":"Adding custom gates","text":"@which instruct!(mreg, mat(FSWAP), (1,2))","category":"page"},{"location":"adding_gates/","page":"Adding custom gates","title":"Adding custom gates","text":"instruct!(reg::MajoranaReg, gate::AbstractMatrix, locs) in FLOYao at ~/.julia/.../FLOYao/src/instruct.jl:49","category":"page"},{"location":"adding_gates/","page":"Adding custom gates","title":"Adding custom gates","text":"to find the location of the corresponding code. Now let's copy-paste what we found there:","category":"page"},{"location":"adding_gates/","page":"Adding custom gates","title":"Adding custom gates","text":"W = FLOYao.qubit2majoranaevolution(Matrix(fswap.content), fswap.locs)","category":"page"},{"location":"adding_gates/","page":"Adding custom gates","title":"Adding custom gates","text":"4×4 Matrix{Float64}:\n -2.35415e-16  -4.12493e-16  -1.0           0.0\n  2.46746e-16  -5.5708e-16   -1.26504e-16  -1.0\n -1.0          -1.17708e-16   2.55988e-16  -2.38988e-16\n -1.85286e-16  -1.0           2.44068e-16   2.43374e-16","category":"page"},{"location":"adding_gates/","page":"Adding custom gates","title":"Adding custom gates","text":"matlocs = 2*(fswap.locs[1]-1)+1:2(fswap.locs[end])","category":"page"},{"location":"adding_gates/","page":"Adding custom gates","title":"Adding custom gates","text":"1:4","category":"page"},{"location":"adding_gates/","page":"Adding custom gates","title":"Adding custom gates","text":"this matrix gets left-multiplied to the columns 1:4 in the last line of FLOYao.majorana_unsafe_apply!(::MajoranaReg, ::PutBlock). So we can instead implement the action of an FSWAP gate on a MajoranaReg directly as follows:","category":"page"},{"location":"adding_gates/","page":"Adding custom gates","title":"Adding custom gates","text":"function YaoBlocks.unsafe_apply!(reg::MajoranaReg, b::PutBlock{2,2,FSWAPGate})\n    FLOYao.areconsecutive(b.locs) || throw(NonFLOException(\"FSWAP must act on consecutive qubits\"))\n    instruct!(reg, Val(:FSWAP), b.locs)\nend\n\nfunction Yao.instruct!(reg::MajoranaReg, ::Val{:FSWAP}, locs::Tuple)\n    i1, i2 = locs\n    row1, row2 = reg.state[2i1-1,:], reg.state[2i1,:]\n    row3, row4 = reg.state[2i2-1,:], reg.state[2i2,:]\n    reg.state[2i1-1,:] .=  .-row3\n    reg.state[2i1,:] .=  .-row4\n    reg.state[2i2-1,:] .=  .-row1\n    reg.state[2i2,:] .=  .-row2\n    return reg\nend","category":"page"},{"location":"adding_gates/","page":"Adding custom gates","title":"Adding custom gates","text":"@benchmark apply!($mreg, $fswap)","category":"page"},{"location":"adding_gates/","page":"Adding custom gates","title":"Adding custom gates","text":"BenchmarkTools.Trial: 10000 samples with 676 evaluations.\n Range (min … max):  183.416 ns …   4.023 μs  ┊ GC (min … max): 0.00% … 93.94%\n Time  (median):     198.760 ns               ┊ GC (median):    0.00%\n Time  (mean ± σ):   224.080 ns ± 242.728 ns  ┊ GC (mean ± σ):  9.29% ±  8.02%\n\n  ▇ ▆ █▁▅ ▁                                                      \n  █▅███████▆▆▅▄▃▃▃▂▃▂▂▂▂▂▂▂▂▂▂▂▁▂▂▂▂▂▂▂▁▁▁▂▂▁▁▁▂▂▂▁▂▁▂▂▂▂▂▂▂▂▂▂ ▃\n  183 ns           Histogram: frequency by time          362 ns <\n\n Memory estimate: 512 bytes, allocs estimate: 4.","category":"page"},{"location":"adding_gates/","page":"Adding custom gates","title":"Adding custom gates","text":"Which is indeed a significant speed-up!","category":"page"}]
}
